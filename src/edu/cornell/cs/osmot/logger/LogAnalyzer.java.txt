package edu.cornell.cs.osmot.logger;

import java.sql.*;
import java.util.Hashtable;
import java.util.Arrays;
import java.util.GregorianCalendar;

// Used when we read log from files.
//import java.util.regex.Pattern;
//import java.util.regex.Matcher;
//import java.util.TreeSet;
//import java.io.BufferedReader;
//import java.io.FileInputStream;
//import java.io.InputStreamReader;

import edu.cornell.cs.osmot.options.Options;

import java.io.IOException;

import com.imsl.math.Sfun; // For erf()

/**
 * This class implements analysis of log files as generated by the search
 * engine. It allows you to load log files for further processing, and analyzing
 * the comparison log files to see if the two search engines being evaluated are
 * significantly different, and which is better.
 * 
 * @author Filip Radlinski
 * @version 1.0, May 2005
 */
public class LogAnalyzer {

	private static Connection connection = null;
	private static String connectionURL = Options.get("LOG_DB");
	private static String sqlUsername = Options.get("LOG_USER");
	private static String sqlPassword = Options.get("LOG_PWD");
	private static boolean debug = false;
	
	static {
		debug = Options.getBool("DEBUG");
	}
	
	/**
	 * See how many votes each of the two ranking functions got from an
	 * interleaving experiment using the original interleaving style.
	 *  
	 * @param logFiles
	 * @return
	 */
	public static int[] comparePerformance(QueryEntry queries[]) {
		
		int preferences[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; 
		// Number of times prefer 1, prefer neither, prefer 2
		// Followed by number of times prefer 1 by -6, -5, -4, ... 0, 1,... 6 
		
		Logger.log(queries.length + " queries found.");

		for (int i = 0; i < queries.length; i++) {

			//Date d = new Date(queries[i].getTime());
			//log("Query "+queries[i].getQuery()+" ("+d.toString()+") has
			// "+queries[i].getNumResults()+" results,
			// "+queries[i].getNumClicks()+" clicks.");

			if (queries[i].getNumClicks() > 0) {

				int clicks1 = 0;
				int clicks2 = 0;
				
				int seen[] = queries[i].getMaxSeen();
	
				int[] cl = queries[i].getClicklist();
				int[] ranks1 = queries[i].getRanks1();
				int[] ranks2 = queries[i].getRanks2();
	
				if (ranks1 == null) {
					Logger.log("Error: ranks1 is null in comparePerformance...");
					Logger.log("Results are " + queries[i].getOrigResults());
					// Make sure the user notices
					preferences[0] = -1;
					preferences[1] = -1;
					preferences[2] = -1;
					return preferences;
				}
				if (ranks2 == null) {
					Logger.log("Error: ranks2 is null in comparePerformance...");
					Logger.log("Results are " + queries[i].getOrigResults());
					// Make sure the user notices
					preferences[0] = -1;
					preferences[1] = -1;
					preferences[2] = -1;
					return preferences;
				}
	
				for (int j = 0; j < cl.length; j++) {
					// If the clicked rank is known, and the rank of this document in
					// the first ranking is known (i.e. not very low) and the document
					// is in the top seen documents from the ranking, count the click.
					if (cl[j] != -1 && ranks1[cl[j]] != -1 && ranks1[cl[j]] < seen[0])
						clicks1++;
					if (cl[j] != -1 && ranks2[cl[j]] != -1 && ranks2[cl[j]] < seen[1])
						clicks2++;
				}
					
				if (clicks1 > clicks2)
					preferences[0]++;
				else if (clicks1 == clicks2)
					preferences[1]++;
				else
					preferences[2]++;
					
				// Compute position of this outcome in the preferences array returned
				// and increment that count by 1.
				int pos = 9 - clicks1 + clicks2;
				if (pos < 3) pos = 3;
				if (pos > 15) pos = 15;
				preferences[pos]++;
				
				//log("C_A = "+clicks1+", C_B = "+clicks2+", C_total =
				// "+(clicks1+clicks2)+", Ratio =
				// "+((1.0*clicks1-clicks2)/(clicks1+clicks2)));
			} else {

				//log("No clicks");
			}
		}

		return preferences;
	}

	/**
	 * @param logFiles
	 * @return
	 */
	public static String getPerformanceData(QueryEntry queries[]) {

		String output = "#IP\tqTime\tk\tclicks1\tcl1\tclicks2\tcl2\tsign(clicks1-clicks2)\n";
		Logger.log(queries.length + " queries found.");

		for (int i = 0; i < queries.length; i++) {

			//Date d = new Date(queries[i].getTime());
			//log("Query "+queries[i].getQuery()+" ("+d.toString()+") has
			// "+queries[i].getNumResults()+" results,
			// "+queries[i].getNumClicks()+" clicks.");

			if (queries[i].getNumClicks() > 0) {

				int clicks1 = 0;
				int clicks2 = 0;
				
				String cl1="";
				String cl2="";
				
				int seen[] = queries[i].getMaxSeen();
					
				int[] cl = queries[i].getClicklist();
				int[] ranks1 = queries[i].getRanks1();
				int[] ranks2 = queries[i].getRanks2();

				if (ranks1 == null) {
					Logger.log("Error: ranks1 is null in comparePerformance...");
					Logger.log("Results are " + queries[i].getOrigResults());
					// Make sure the user notices
					return "Error: Ranks1 is null in comparePerfomrnace";
				}
				if (ranks2 == null) {
					Logger.log("Error: ranks2 is null in comparePerformance...");
					Logger.log("Results are " + queries[i].getOrigResults());
					// Make sure the user notices
					return "Error: Ranks2 is null in comparePerformance";
				}

				for (int j = 0; j < cl.length; j++) {
					if (cl[j] != -1 && ranks1[cl[j]] != -1 && ranks1[cl[j]] < seen[0]) {
						cl1 += ranks1[cl[j]]+":";
						clicks1++;
					}
					if (cl[j] != -1 && ranks2[cl[j]] != -1 && ranks2[cl[j]] < seen[1]) {
						cl2 += ranks2[cl[j]]+":";
						clicks2++;
					}
				}
					
				output += queries[i].getIP()+"\t"+queries[i].getTime()+"\t"+seen[0]+"\t"+clicks1+"\t"+cl1+"\t"+seen[1]+"\t"+clicks2+"\t"+cl2+"\t";
				if (clicks1 > clicks2) {
					output += "1\n";
				} else if (clicks1 == clicks2) {
					output += "0\n";
				} else {
					output += "-1\n";
				}
					
			} else {

				//log("No clicks");
			}
		}

		return output;
	}


	
	/**
	 * 
	 * @param logFiles
	 * @throws IOException
	 */
	public static void countPairs(String mode, QueryEntry queries[]) throws IOException {

		int pairOffset;
		
		if (mode.equals("3a")) {
			pairOffset = 0;
		} else {
			pairOffset = 1;
		}
				
		Logger.log(queries.length + " queries found.");

		for (int i = 0; i < queries.length; i++) {

			Logger.log("Query "+queries[i].getQuery()+" has "+
					queries[i].getNumResults()+" results, "+
					queries[i].getNumClicks()+" clicks.");
			
			Logger.log("Query Details: displayed "+queries[i].getOrder());

			if (queries[i].getNumClicks() > 0) {

				queries[i].getPairsDisplayed(pairOffset);
				queries[i].getPairsClicked(pairOffset);
				
			} else {

				Logger.log("No clicks");
			}
		}
	}
	
	/**
	 * Returns an array of log entries
	 *  
	 * @param selectClause  Restrict to entries matching this arbitrary SQL
	 * @return An array of log entries.
	 */
	public static QueryEntry[] loadLog(String selectClause) {
		return loadLog(selectClause, "");
	}
	
	/**
	 * Returns an array of log entires
	 * 
	 * @param selectClause  Restrict to entries matching this arbitrary SQL
	 * @param mode          Restrict to queries with this mode
	 * @return An array of log entries.
	 */
	public static QueryEntry[] loadLog(String selectClause, String mode) {

		Hashtable h = new Hashtable(); // Contains the queries
		Hashtable hDate = new Hashtable(); // Contains the date queries
		QueryEntry qe;
		ClickEntry ce;

		try {
			Class.forName("com.mysql.jdbc.Driver");
			connection = DriverManager.getConnection(connectionURL, sqlUsername, sqlPassword);
		} catch (Exception e) {
			System.err.println("SQL Error: "+e.toString());
		}
		
		String sqlQuery = "";

		try {
			Statement statement = null;
			statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			
			// First, get the queries from the log.
			if (mode != null && !mode.equals(""))
				sqlQuery = "SELECT * FROM queries WHERE mode = '"+mode+"'";
			else
				sqlQuery = "SELECT * FROM queries";
			
			if (selectClause != null && selectClause.length() > 0) {
				if (mode == null || mode.equals(""))
					sqlQuery += " WHERE "+selectClause;
				else
					sqlQuery += " AND "+selectClause;
			}

            if(debug) Logger.log("executing query: " + sqlQuery);
			ResultSet rs = statement.executeQuery(sqlQuery);
		
			if (rs.first()) {
				do {
					String qid = rs.getString("qid");
                    if(debug) Logger.log("query: " + qid);
					Timestamp date = rs.getTimestamp("date");
					
					// TODO: Remove! Note that qid is used more below.;
					// Work around for logging but 10/11/06 to 10/19/06
					GregorianCalendar sentinel = new GregorianCalendar(106+ 1900, 9, 19, 11, 20, 0);
					if (qid.length() > 32 && date.before(sentinel.getTime()))
						qid = qid.substring(0, 32);
					
				    // Ignore queries from in the past, i.e. bookmarked with qid or something like that.
					// Only works for new time format.
				    boolean ignore = false;
				    if (qid.length() > 13) {
				    	long qidTime = Long.parseLong(qid.substring(0,13));
					    long dateTime = date.getTime();
					    // If the date of the run and the qid differ by more than a day, ignore the query
					    if (Math.abs(qidTime - dateTime) > 24 * 3600 * 1000)
						ignore = true;
				    } else {
				    	System.err.println("qid was "+qid);
				    	ignore = true;
				    }
				    
				    if (!ignore) {					
					
				    	String useragent = rs.getString("useragent");
				    	qe = new QueryEntry(date.getTime(), rs.getString("query"), qid,
				    			rs.getString("ip"), rs.getString("session"), rs.getString("referer"),
				    			rs.getString("results"),"",rs.getString("mode"),useragent.substring(0,32));					

				    	// Only include non-blank queries, and only include the query the *first*
				    	// time it shows up in the log (some are repeated due to a logging bug)
				    	if (qe.getQuery().length() > 0 && !h.containsKey(qe.getQid()))
				    		h.put(qe.getQid(), qe);
				    }
                    else
                    {
                        if(debug) Logger.log("Ignored: " + qid);
                    }
					
				} while (rs.next());
			}
			rs.close();
            if(debug) Logger.log("Num query logs loaded: " + h.size());
			
			// Now get the date mode queries from the same period
			// First, get the queries from the log.
			sqlQuery = "SELECT * FROM queries WHERE mode = 'dt'";
			if (selectClause != null && selectClause.length() > 0) {
				sqlQuery += " AND "+selectClause;
			}
			rs = statement.executeQuery(sqlQuery);
		
			if (rs.first()) {
				do {
					String qid = rs.getString("qid");
					Timestamp date = rs.getTimestamp("date");
					
					// TODO: Remove! Note that qid is used more below.
					// Work around for logging but 10/11/06 to 10/19/06
					GregorianCalendar sentinel = new GregorianCalendar(106+ 1900, 9, 19, 11, 20, 0);
					if (qid.length() > 32 && date.before(sentinel.getTime()))
						qid = qid.substring(0, 32);
					
				    // Ignore queries from in the past, i.e. bookmarked with qid or something like that.
					// Only works for new time format.
				    boolean ignore = false;
				    if (qid.length() > 13) {
				    	long qidTime = Long.parseLong(qid.substring(0,13));
					    long dateTime = date.getTime();
					    // If the date of the run and the qid differ by more than a day, ignore the query
					    if (Math.abs(qidTime - dateTime) > 24 * 3600 * 1000)
						ignore = true;
				    } else {
				    	System.err.println("qid was "+qid);
				    	ignore = true;
				    }
				    
				    if (!ignore) {					
					
				    	String useragent = rs.getString("useragent");
				    	qe = new QueryEntry(date.getTime(), rs.getString("query"), qid,
				    			rs.getString("ip"), rs.getString("session"), rs.getString("referer"),
				    			rs.getString("results"),"",rs.getString("mode"),useragent.substring(0,32));					

				    	// Only include non-blank queries, and only include the query the *first*
				    	// time it occurs, and only include queries that match a non-date query
				    	if (qe.getQuery().length() > 0 && h.containsKey(qe.getQid()) && !hDate.containsKey(qe.getQid()))
				    		hDate.put(qe.getQid(), qe);
				    }
					
				} while (rs.next());
			}
			
			rs.close();
			
			// Then, get the clicks
			
			// When we add clicks (in qe.addClick), we only add the first click on any given document.
			
			// This means we take a big "OR" of the formats, and the first format clicked (typically
			// abs) gets the click. So you shouldn't filter on click format. 
			// Actually, we now just take "abs"
			
			// However, we also record the LAST click time for time to last click computations - since
			// we're measuring time spent in the results, if a document is re-clicked, we want to take
			// that later time. This is taken care of in qe[].addClick() about one screen down.
			
			if (mode != null && !mode.equals(""))
			    sqlQuery = "SELECT * FROM clicks WHERE mode = '"+mode+"' AND format = 'abs'";
			else
			    sqlQuery = "SELECT * FROM clicks WHERE format = 'abs'";

			if (selectClause != null && selectClause.length() > 0) {
				// There is always a where format='abs' now
			    //if (mode == null || mode.equals(""))
				//sqlQuery += " WHERE "+selectClause;
			    //else 
				sqlQuery += " AND "+selectClause;
			}

			rs = statement.executeQuery(sqlQuery);
			
			if (rs.first()) {
				do {
				    String qid = rs.getString("qid");
				    Timestamp date = rs.getTimestamp("date"); // Date of click
				    long dateTime = date.getTime();

				    boolean ignore = false;

				    /* Doesn't happen any more, I think.				    
				    // If the click date and the query date differ by more than 24 hours, ignore the click
				    if (qid.length() > 13) {
					    long qidTime = Long.parseLong(qid.substring(0,13));
					    if (Math.abs(qidTime - dateTime) > 24 * 3600 * 1000)
					    	ignore = true;
				    } else {
					//System.err.println("Click qid was too short: "+qid);
				    	ignore = true;
				    }
				    */
							    
				    // TODO: Remove this, since new log entries no longer have this problem.
				    // If the click mode doesn't match the query mode, ignore the click
				    String qidMode = Logger.qidMode(qid);
				    if (qidMode != null && mode != null && !mode.equals("") && !qidMode.equals(mode)) {
					    //System.err.println("Mode doesn't match query mode "+qid+" v.s. "+mode);
				    	ignore = true;
				    }
				    
				    if (!ignore) {					
				    	ce = new ClickEntry(dateTime, rs.getString("format"), rs.getString("paper"),
				    			qid, rs.getString("ip"), rs.getString("session"));

				    	qe = (QueryEntry) h.get(ce.getQid());

					// No query = no match
					if (qe == null) {
						ignore = true;
					}

				    	// Make sure the sessions match
				    	if (!ignore && !qe.getSession().equals(ce.getSession())) {
				    		ignore = true;
				    	}
				    	
				    	// Check the query time and the time of the date
					    long qTime = -1;
					    if (!ignore) 
					    	qTime = qe.getTime();
					    long dtTime = -1;
					    if (hDate.containsKey(qid)) {
					    	dtTime = ((QueryEntry) hDate.get(ce.getQid())).getTime();
					    }
					    // If the click is before the query, or if it is after a date query, ignore it					    
					    if (qTime > dateTime || (dtTime != -1 && dtTime < dateTime)) {
					    	ignore = true;
					    }
					    
						if (!ignore) {
							qe.addClick(ce);
							h.put(qe.getQid(), qe);
						} else {
							Logger.log("Warning: Can't see query for click "
									+ ce.toString());
						}
				    }

				} while (rs.next());
			}

			// Then, get the downloads
			
			// When we add downlodss (in qe.addDownload, we only add the first click on any given document.
			
			// This means we take a big "OR" of the formats, and the first format clicked (typically
			// abs) gets the click. So you shouldn't filter on click format. 
			// Actually, we now just take "abs"
			
			// However, we also record the LAST click time for time to last click computations - since
			// we're measuring time spent in the results, if a document is re-clicked, we want to take
			// that later time. This is taken care of in qe[].addClick() about one screen down.
			
            sqlQuery = "SELECT * FROM clicks WHERE format = 'pdf'";

			if (selectClause != null && selectClause.length() > 0) {
				// There is always a where format='abs' now
			    //if (mode == null || mode.equals(""))
				//sqlQuery += " WHERE "+selectClause;
			    //else 
				sqlQuery += " AND "+selectClause;
			}

			rs = statement.executeQuery(sqlQuery);
			
			if (rs.first()) {
				do {
				    String qid = rs.getString("qid");
				    Timestamp date = rs.getTimestamp("date"); // Date of click
				    long dateTime = date.getTime();

				    boolean ignore = false;

				    /* Doesn't happen any more, I think.				    
				    // If the click date and the query date differ by more than 24 hours, ignore the click
				    if (qid.length() > 13) {
					    long qidTime = Long.parseLong(qid.substring(0,13));
					    if (Math.abs(qidTime - dateTime) > 24 * 3600 * 1000)
					    	ignore = true;
				    } else {
					//System.err.println("Click qid was too short: "+qid);
				    	ignore = true;
				    }
				    */
							    
				    // TODO: Remove this, since new log entries no longer have this problem.
				    // If the click mode doesn't match the query mode, ignore the click
				    String qidMode = Logger.qidMode(qid);
				    if (qidMode != null && mode != null && !mode.equals("") && !qidMode.equals(mode)) {
					//System.err.println("Mode doesn't match query mode "+qid+" v.s. "+mode);
				    	ignore = true;
				    }
				    
				    if (!ignore) {					
                        ce = new ClickEntry(dateTime, rs.getString("format"), rs.getString("paper"),
                                qid, rs.getString("ip"), rs.getString("session"));

                        qe = (QueryEntry) h.get(ce.getQid());

                        // No query = no match
                        if (qe == null) {
                            ignore = true;
                            Logger.log("Warning: no query entry for " + ce.toString());
                        }

                        // Make sure the sessions match
                        if (!ignore && !qe.getSession().equals(ce.getSession())) {
                            ignore = true;
                            Logger.log("Warning: session incorrect for " + ce.toString());
                        }

                        // Check the query time and the time of the date
                        long qTime = -1;
                        if (!ignore) 
                            qTime = qe.getTime();
                        long dtTime = -1;
                        if (hDate.containsKey(qid)) {
                            dtTime = ((QueryEntry) hDate.get(ce.getQid())).getTime();
                        }
                        // If the click is before the query, or if it is after a date query, ignore it					    
                        if (qTime > dateTime || (dtTime != -1 && dtTime < dateTime)) {
                            ignore = true;
                        }

                        if (!ignore) {
                            qe.addDownload(ce);
                            Logger.log("Logging download " + ce.toString());
                            h.put(qe.getQid(), qe);
                        } else {
                            Logger.log("Warning: Can't see query for download "
                                    + ce.toString() + " " + ce.getQid());
						}
				    }

				} while (rs.next());
			}
			
			rs.close();
			
		} catch (SQLException e) {
			Logger.log("ERROR: SQL Exception when logging query " + sqlQuery + ": " + e.toString());
		}
		
		try {
			connection.close();
		} catch (SQLException e) {
			Logger.log("ERROR: SQL Exception when logging query " + sqlQuery + ": " + e.toString());			
		}
			
		QueryEntry[] entries = new QueryEntry[0];
		entries = (QueryEntry[]) (h.values().toArray(entries));

		Arrays.sort(entries);

		if (debug)
			for(int i=0; i<entries.length; i++)
				Logger.log("Time of "+i+": "+entries[i].toString());
		
		return entries;
	}
	
	/** Work out today's usage */
	
	public static String usageStats() {
	
		try {
			Class.forName("com.mysql.jdbc.Driver");
			connection = DriverManager.getConnection(connectionURL, sqlUsername, sqlPassword);
		} catch (Exception e) {
			System.err.println("SQL Error: "+e.toString());
		}
		
		// First, from the user perspective
		
		String sqlQuery = "select mode, count(*) as n from queries where date_format(date,\"%Y-%m-%d\")=curdate() group by mode";
		String output = "";
		
		try {
			Statement statement = null;
			statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);			
			ResultSet rs = statement.executeQuery(sqlQuery);
		
			if (rs.first()) {
				do {
					String mode = rs.getString("mode");
					int n = rs.getInt("n");
					output += mode+" "+n+"\n";
				} while (rs.next());
			}
			rs.close();
		} catch (SQLException e) {
			Logger.log("ERROR: SQL Exception computing usage stats " + sqlQuery + ": " + e.toString());
		}
		
		// Then the additions to the index

		sqlQuery = "select success, count(*) as n from additions where date_format(date,\"%Y-%m-%d\")=curdate() group by success";

		try {
			Statement statement = null;
			statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);			
			ResultSet rs = statement.executeQuery(sqlQuery);
		
			if (rs.first()) {
				do {
					int n = rs.getInt("n");
					String success = rs.getString("success");
					output += "Index updates (success,n): "+success+","+n+"\n";
				} while (rs.next());
			}
			rs.close();
		} catch (SQLException e) {
			Logger.log("ERROR: SQL Exception computing usage stats " + sqlQuery + ": " + e.toString());
		}
				
		return output;
	}
	
	/**
	 * #@deprecated Use the database
	 * 
	 * Returns a query entry from the log line, or null if the line is not a
	 * query entry.
	 * 
	 * @param line
	 *            A line from the log file.
	 * @return The line parsed into a query entry, or null if its not a query
	 *         entry
	 
	private static QueryEntry parseQueryLine(String line, String mode) {

		// The weird "default" thing here is for backward compatilibty
		// with a previous version of the log file format.
		String pattern = "^([0-9]+) q:(.*) qid:([0-9-]+) ip:([0-9\\.]+) s:([0-9A-Z]+) ref:(.+) ([default ]*)n:([0-9]+) ?(.*)$";
		Pattern p = Pattern.compile(pattern);
		Matcher m = p.matcher(line);
		
		// New pattern used to record order things were actuall presented if
		// a random replacement was done.
		String pattern2 = "^([0-9]+) q:(.*) qid:([0-9-]+) ip:([0-9\\.]+) s:([0-9A-Z]+) ord:([0-9#ONC]*) ref:(.+) n:([0-9]+) ?(.*)$";
		Pattern p2 = Pattern.compile(pattern2);
		Matcher m2 = p2.matcher(line);
		
		if (m.find()) {
			return new QueryEntry(Long.parseLong(m.group(1)), m.group(2), m
					.group(3), m.group(4), m.group(5), m.group(6), m.group(9), "", mode);
		} else if (m2.find()) {
			return new QueryEntry(Long.parseLong(m2.group(1)), m2.group(2), m2
					.group(3), m2.group(4), m2.group(5), m2.group(7), m2.group(9), m2.group(6), mode);			
		}

		return null;
	}
    */
	
	/**
	 * #@deprecated Use the database
	 * 
	 * Returns a click entry from the log line, or null if the line is not a
	 * click entry.
	 * 
	 * @param line
	 *            A line from the log file.
	 * @param onlyDocs
	 * 			 Clicks can be labelled with the type of click: i.e. the log entry can
	 *            record additional information. We use this in our experiments. You 
	 *            probably want the value to be false. In thise case clicks are assumed
	 *            to have labels "abs:"
	 * @return The line parsed into a click entry, or null if its not a click
	 *         entry.
	 *
	private static ClickEntry parseClickLine(String line) {

		String clickPattern = Options.get("LEARNER_CLICK_PATTERN");		
		String pattern = "^([0-9]+) ("+clickPattern+"):(.*) qid:(.*) ip:(.*) s:(.*)$";
		Pattern p = Pattern.compile(pattern);
		Matcher m = p.matcher(line);
		if (m.find() && !m.group(4).equals("null")) {
			return new ClickEntry(Long.parseLong(m.group(1)), m.group(2), m
					.group(3), m.group(4), m.group(5), m.group(6));
		}

		return null;
	}
    */
	
	/** 
	 * Return the p-value of a binomial sign test. 
	 */
	public static double pValue(int i1, int i2) {
		double z = 1.0 * Math.abs(i1 - i2);
		z = (z - 1) / Math.sqrt(i1 + i2);

		double p = 2 * (0.5 - 0.5 * Sfun.erf(z / Math.sqrt(2)));

		return Math.min(1,p);
	}
	
	/** 
	 * Test harness
	 */
	public static void main(String args[])  {
		// This is the query we want to load 
		String filter = "qid IN ('12021086964085cr213.423nN-534317300','12021057853405cr213.423nN1615032826')";
		QueryEntry qe[] = loadLog(filter, "5c");

		for (int i=0; i<qe.length; i++) {
			System.out.println("Query with id "+qe[i].getQid()); 
				
			int ranks[] = qe[i].getRanks1();
			System.out.print("Ranks1 = ");
			for (int j=0; ranks!=null && j<ranks.length; j++) {
				System.out.print(ranks[j]+":");
			}
			System.out.println();

			ranks = qe[i].getRanks2();
			System.out.print("Ranks2 = ");
			for (int j=0; ranks!=null && j<ranks.length; j++) {
				System.out.print(ranks[j]+":");
			}
			System.out.println();

			int clickList[] = qe[i].getClicklist();
			System.out.print("Clicklist = ");
			for (int j=0; j<clickList.length; j++) 
				System.out.print(clickList[j]+":");
			System.out.println();

			int seen[] = qe[i].getMaxSeen();
			System.out.println("Seen is "+seen[0]+":"+seen[1]);

		}
		System.out.println(getPerformanceData(qe));
	}
	
}

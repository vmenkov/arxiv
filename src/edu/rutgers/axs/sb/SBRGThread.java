package edu.rutgers.axs.sb;

import java.io.*;
import java.util.*;
import java.text.*;
import java.util.regex.*;

import javax.persistence.*;

import org.apache.lucene.document.*;
import org.apache.lucene.index.*;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.ScoreDoc;


import edu.rutgers.axs.sql.*;
import edu.rutgers.axs.web.*;
import edu.rutgers.axs.indexer.*;

class SBRGThread extends Thread {
    private final SBRGenerator parent;
    //    private final long sid;
    /** Creates a thread. You must call its start() next */
    SBRGThread(SBRGenerator _parent) {
	parent = _parent;
    }

    /** The number of actions 
     */
    int actionCount=0;
    int articleCount=0;
    
    Date startTime, endTime;

    /** The main class for the actual generation */
    public void run()  {
	startTime = new Date();
	
	IndexReader reader=null;
	IndexSearcher searcher = null;

	try {
	    reader=Common.newReader();
	    searcher = new IndexSearcher( reader );
	    // get the list of article id, using whatever algorithm
	    computeRecList(searcher);
	    // add article title etc to each entry

	    /* // not needed for the new computeRecList()
	    for(ArticleEntry ae: sr.entries) {
		ae.populateOtherFields(searcher);
	    }
	    */
	} catch(IOException ex) {
	    error = true;
	    errmsg = ex.getMessage();
	    System.out.println("Exception for SBRG thread " + getId());
	    ex.printStackTrace(System.out);
	    //sr = null;
	} finally {
	    try {
		if (searcher!=null) searcher.close();
		if (reader!=null) reader.close();
	    } catch(IOException ex) {}
	    endTime = new Date();
	}
	parent.completeRun();

    }

    /** The reommendation list generated by this method */
    public SearchResults sr=null;
    //    PresentedList pl;

    boolean error = false;
    String errmsg = "";
   
    private Vector<String> listViewedArticles(EntityManager em) {
	Vector<Action> va = Action.actionsForSession( em, parent.sd.getSqlSessionId());
	actionCount = va.size();
	Vector<String> viewedArticles = new Vector<String>();
	HashSet<String> h = new HashSet<String>();
	for(Action a: va) {
	    Article art = a.getArticle();
	    String aid = art.getAid();
	    if (!h.contains(aid)) {
		viewedArticles.add(aid);
		h.add(aid);
	    }
	}
	articleCount=viewedArticles.size();
	return viewedArticles;
    }

    /** For ascending-order sort, i.e. rank 1 before rank 2 etc */
    private static class ArticleRanks implements Comparable<ArticleRanks> {
	int docno;
	/** This is *not* used for sorting */
	double score=0;
	Vector<Integer> ranks=new Vector<Integer>();
	public int compareTo(ArticleRanks o) {
	    for(int i=0; i<ranks.size() && i<o.ranks.size(); i++) {
		int z=ranks.elementAt(i).intValue() - o.ranks.elementAt(i).intValue();
		if (z!=0) return z;
	    }
	    return o.ranks.size() - ranks.size();
	}
	ArticleRanks(int _docno) { docno = _docno; }
	/** Should be called in order of non-decreasing r */
	void add(int r, double deltaScore) {
	    if (ranks.size()>0 && r<ranks.elementAt(ranks.size()-1).intValue()){
		throw new IllegalArgumentException("ArticleRanks.add() calls must be made in order");
	    }
	    ranks.add(new Integer(r));
	    score +=  deltaScore;
	}
    }

    String excludedList = "";
 
    private void computeRecList(IndexSearcher searcher) {
	EntityManager em=null;
	try {
	    em = parent.sd.getEM();       
	    Vector<String> viewedArticles = listViewedArticles(em);

	    HashSet<String> exclusions = parent.linkedAids;
	    exclusions.addAll(viewedArticles);

	    // abstract match, separately for each article
	    final int maxlen = 100;
	    final int maxRecLenTop = 25;
	    final int maxRecLen = Math.min(3*viewedArticles.size(), maxRecLenTop);
	    ScoreDoc[][] asr  = new ScoreDoc[viewedArticles.size()][];
	    int k=0;
	    for(String aid: viewedArticles) {
		ScoreDoc[] z = parent.articleBasedSD.get(aid);
		if (z==null) {
		    int docno= Common.find(searcher, aid);
		    Document doc = searcher.doc(docno);
		    String abst = doc.get(ArxivFields.ABSTRACT);
		    abst = abst.replaceAll("\"", " ").replaceAll("\\s+", " ").trim();
		    z = (new LongTextSearchResults(searcher, abst, maxlen)).scoreDocs;
		    parent.articleBasedSD.put(aid,z);
		}
		asr[k++] = z;
	    }

	    // merge all lists
	    //	    HashMap<String,ArticleRanks> hr= new HashMap<String,ArticleRanks>();
	    HashMap<Integer,ArticleRanks> hr= new HashMap<Integer,ArticleRanks>();
	    for(int j=0; j<maxlen; j++) {
		for(ScoreDoc[] z: asr) {
		    if (j<z.length) {
			int docno = z[j].doc;
			Integer key = new Integer(docno);
			ArticleRanks r= hr.get(key);
			if (r==null) { 
			    hr.put(key, r=new ArticleRanks(docno));
			}
			r.add(j, z[j].score);		      
		    }
		}
	    }
	    ArticleRanks[] ranked = (ArticleRanks[])hr.values().toArray(new ArticleRanks[0]);
	    Arrays.sort(ranked);

	    Vector<ArticleEntry> entries = new Vector<ArticleEntry>();
	    k=1;
	    for(ArticleRanks r: ranked) {
		/*
		ArticleEntry ae = new ArticleEntry(++k, r.aid);
		ae.setScore(r.score);
		*/
		ArticleEntry ae= new ArticleEntry(k, searcher.doc(r.docno),
						  new ScoreDoc(r.docno, (float)r.score));
		if (exclusions.contains(ae.id)) {
		    excludedList += " " + ae.id;
		    continue;
		}
		entries.add(ae);
		k++;
		if (entries.size()>=maxRecLen) break;
	    }
	    sr = new SearchResults(entries); 
	    //sr.saveAsPresentedList(em,Action.Source.SB,null,null, null);
	}  catch (Exception ex) {
	    error = true;
	    errmsg = ex.getMessage();
	    Logging.error(""+ex);
	    System.out.println("Exception for SBRG thread " + getId());
	    ex.printStackTrace(System.out);
	} finally {
	    ResultsBase.ensureClosed( em, true);
	}
    }

    private void computeRecListTrivial() {
	EntityManager em=null;
	try {
	    em = parent.sd.getEM();       
	    Vector<String> viewedArticles = listViewedArticles(em);
	    // trivial list: out=in
	    Vector<ArticleEntry> entries = new Vector<ArticleEntry>();
	    int k=0;
	    for(String aid:  viewedArticles) {
		ArticleEntry ae = new ArticleEntry(++k, aid);
		ae.setScore(1.0);
		entries.add(ae);
	    }
	    sr = new SearchResults(entries); 
	    //sr.saveAsPresentedList(em,Action.Source.SB,null,null, null);
	}  catch (Exception ex) {
	    error = true;
	    errmsg = ex.getMessage();
	    Logging.error(""+ex);
	    System.out.println("Exception for SBRG thread " + getId());
	    ex.printStackTrace(System.out);
	} finally {
	    ResultsBase.ensureClosed( em, true);
	}
    }

    /*
  PresentedList saveAsPresentedList(EntityManager em, User u) {
	PresentedList plist = new PresentedList(Action.Source.SB, u);
	plist.fillArticleList(entries);	
	em.getTransaction().begin();
	em.persist(plist);
	em.getTransaction().commit();
	return plist;
    }
    */

    /** A human-readable description of what this thread had done. */
    public String description() {
	String s = "Session-based recommendation list produced by thread " + getId() +"; started at " + startTime +", finished at " + endTime;
	if (startTime!=null && endTime!=null) {
	    long msec = endTime.getTime() - startTime.getTime();
	    s += " (" + (0.001 * (double)msec) + " sec)";
	}
	s += ".";
	s += " The list is based on " + actionCount + " user actions (" +
	    articleCount + " viewed articles)";
	return s;
    }

}


package edu.rutgers.axs.sql;

import java.util.*;
import javax.persistence.*;

import edu.rutgers.axs.web.Page;
import java.lang.reflect.*;

/** An instance of this class contains information about one call
 */
@Entity
public class User implements OurTable  {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Display(editable=false)
	private long id;

    public void setId(long val) {        id = val;    }
    public long getId() {        return id;    }

    @Basic  @Display(editable=false)
    private long resume;
    /** If a positive, value, refers to another call, which this call
	is meant to be a "resumption" of. 0 means that this is not a
	continuation call */
    public void setResume(long val) {        resume = val;    }
    public long getResume() {        return resume;    }

    @ManyToOne public Respondent respondent;
    public void setRespondent( Respondent val) {   respondent = val;    }
    public Respondent getRespondent() {   return respondent;   }

    @Basic @Display(order=1) @Column(nullable=false,length=32)
	String phone_Number;
    public void setPhone_Number(String val) {  phone_Number        = val;    }
    /** The phone number called. We explicitly records this in the
     * User entry because the recipient's phone number  may change
     */
    public String getPhone_Number() {        return phone_Number ;    }

    @Basic  @Display(order=2)  @Column(nullable=false)  
	Disposition disp_code = Disposition.Started;
    /** Disposition code. "Started" may also mean that the call has not been completed yet */
    public   Disposition getDisp_code() { return disp_code; }
    public void setDisp_code(  Disposition x) { disp_code = x; }

    @Basic   @Display(order=3.1)   @Column(nullable=false,length=32)
	String interviewer;
    /** The user name of the interviewer who conducted (started) this
	interview.  
	*/
    public String getInterviewer() { return interviewer; }
    public void setInterviewer(String x) {  interviewer = x; }


    @Temporal(TemporalType.TIMESTAMP) @Display(order=4.1, alt="Call started at") 
	@Column(nullable=false) 
	Date startTime;
    /** Approximate start time (based on when the interviewer enetered
     * the disposition info)
     */
    public  Date getStartTime() { return startTime; }
    public void setStartTime(       Date x) { startTime = x; }

    @Temporal(TemporalType.TIMESTAMP) @Display(order=4.2, alt="Recording started at")
	@Column(nullable=true) 
	Date recorderStartTime;
    /** Approximate time when the interviewer turned on the recorder. Null
	otherwise.
     */
    public  Date getRecorderStartTime() { return recorderStartTime; }
    public void setRecorderStartTime(       Date x) { recorderStartTime = x; }

    @Temporal(TemporalType.TIMESTAMP) @Display(order=4.3) @Column(nullable=true) 
	Date lastTime;
    /** Last activity time. This is the last time a page has been
     * added (or replaced) in this call's action log. */
    public  Date getLastTime() { return lastTime; }
    public void setLastTime(       Date x) { lastTime = x; }

    @Basic @Display(order=4) @Column(nullable=true,length=255)
	String recordingFileName;
    public  String getRecordingFileName() { return recordingFileName; }
    public void setRecordingFileName(       String x) { recordingFileName = x; }

    /** Values of this class can be stored in the "disp_code" field,
     * and describe various "outcomes" of this call (or an attempt to call)
     */
    public static enum Disposition {	
	@EA(alt="YES, I CAN PARTICIPATE")
	    Started,
	    @EA(alt="VOICE MAIL/ANSWERING MACHINE")
	    Voice_mail, 
	    @EA(alt="NO ANSWER")
	    No_answer, 
	    @EA(alt="DISCONNECTED AFTER ANSWER")
	    Disconnected_after_answer, 
	    @EA(alt="HANG UP")
	    Hang_up,  
            @EA(alt="LANGUAGE PROBLEM")
            Language_Problem,
            @EA(alt="NOT IN SERVICE")
            Not_in_service, 
            @EA(alt="WRONG NUMBER")
            Wrong_number,
	    @EA(alt="NOT A GOOD TIME/NOT AVAILABLE, PLEASE RESCHEDULE")
	    Not_Available,
	    @EA(alt="REFUSED / DON'T KNOW")
	    Refused,
	    @EA("The respondent cannot answer an essential question")
	    Cannot_Answer,
	    @EA(alt="NEVER OFFERED ICD")
	    Never_Offered,
	    @EA("E.g. is a RU employee")
	    Other_Ineligible,
	    @EA("Successfully completed")
	    Completed,
	    @EA("Asked to quit, and does not want to ever continue")
	    FinishedIncomplete,
	    @EA("Partially answered, must call later to complete")
	    ToBeResumed;

	/** List of dispositions that can appear in page 1 */
	public static final Disposition[] p1disp = {
	    Started,
	    Voice_mail, 
	    No_answer, 
	    Disconnected_after_answer, 
	    Hang_up, Language_Problem, Not_in_service, Wrong_number,
	    Not_Available,
	    Refused,
	    Never_Offered
	};

	/** Maps multiple outcomes to a smaller number of
	 * actions. Only needs to be defined on actions that may
	 * appear in page 1 */
	public DispositionSimplified simplify () {
	    switch (this) {
		case Started:
		    return  DispositionSimplified.Continue;
		case Not_Available:
		    return  DispositionSimplified.RescheduleAndTryLater;
		case Voice_mail:
		case No_answer:
		    return  DispositionSimplified.TryLater;
		default:
		    return  DispositionSimplified.Eliminate;
	    }


	}
    }

    /** Maps multiple outcomes to a smaller number of actions */
    public static enum DispositionSimplified {	
	Continue, 
	    @EA("Will ask the person for the best time to call again")
	    RescheduleAndTryLater, 
	    @EA("Will try calling again later")
	    TryLater, 
	    @EA("Shall not call this person again")
	    Eliminate;
    }

	/*
	static String getSimplifiedAnnotation(Disposition d) {
	    DispositionSimplified ds = simplify(d);

	    SimplifiedAnnotatio
	    	    Field f = null;
	    try {
		f = t.getDeclaredField(con[j].toString());
	    } catch (NoSuchFieldException ex) {	    }
	    EA anno = (f==null)? null: (EA)f.getAnnotation(EA.class);
	    //	    Logging.info("object=" + con[j]+", f="+f+", anno=" + anno);
	    boolean selected = (old == null)? (j==0): (old==con[j]);
	    String text = con[j].toString();
	    String annoText = anno.value();
	}
	*/



    @OneToMany(cascade=CascadeType.ALL)
	private Set<Action> actions = new LinkedHashSet<Action>();

    public Set<Action> getActions() {
	return actions;
    }

    static public final String SAVE = "save_call.";
    static public final String SAVE_DISP = SAVE + "disp_code";
    static public final String DISP = "disp_code";
    static public final String SAVE_REC_FILE_NAME = SAVE + "recordingFileName";

    static {
	Reflect.getReflect(Respondent.class);
    }

    public User() {}

    /** Creates a new User entry. Records the creation time,
     * information of the respondent (the person whom this call is
     * made to), as well as the phone number being used.
     */
    public User(Respondent r, String user) {	
	setRespondent( r );
	setPhone_Number( r.getPhone_Number());
	setStartTime(  (new GregorianCalendar()).getTime());
	setInterviewer(user);
    }

    public String reflectToStringBasic() {
	return Reflect.reflectToString(this);
    }


    public String reflectToString() {
	return Reflect.customizedReflect(this, 
					 new PairFormatter.CompactPairFormatter());
    }

    public Action addAction(String p//, Date now
				) {
	Action r = new  Action( this, p); //, now);
	actions.add(r);	
	return r;
    }

    /** Looks up an existing action for a given page, or creates a
	new one.  Note: this should not be used much, as page name may
	not be a unique id within a call
     */
    public Action getAction(String p) { 
	Action r = findAction(p);
	return  (r!=null)? r : addAction(p); 
    }

    /** Looks up an existing action for a given page.
	@return The first found matching action, or null
     */
    private Action findAction(String p) { 
	for(Action r: actions) {
	    if (r.getPage().equals(p)) {
		return r;
	    }
	}
	return null;
    }


    /** FIXME: Have to be set explicitly, by calling actionCnt() and 
	 substantiveActionCnt()
     * while connected to the EM is alive */
    @Transient public int actionCnt=-1, substantiveActionCnt=-1;
    /** The last recorded  susbstantive answer */
    @Transient public int lastSubstantivePageIndex = -1;
    /** If one were to start another call as a continuation of this call,
	this would be the first question to ask:
     */
    @Transient public Page resumeFrom = null;

    /** FIXME: this won't work unless we're connected to EM at the moment!
     */
    public int computeActionCnt() {
	return  actionCnt=actions.size();
    }

   /** FIXME: this won't work unless we're connected to EM at the moment!
     */
     public synchronized int computeSubstantiveActionCnt() {
	int n = 0;
	for(Action q: actions) {
	    if (!q.hasSubstantiveAnswer()) continue;
	    n++;
	    Page p = Page.findPage(q.getPage());
	    if (p!=null) {
		int si = Page.getSubstantiveIndex(p);
		if (si > lastSubstantivePageIndex) {
		    lastSubstantivePageIndex = si;
		}
	    }
	}
	return substantiveActionCnt=n;
    }

    public void computeTransient(EntityManager em) {
	computeActionCnt();
	computeSubstantiveActionCnt();
	resumeFrom = shouldResumeFrom(em); 
	Logging.info("Computed for call=" + getId() + ": actionCnt=" + actionCnt +",  substantiveActionCnt=" +  substantiveActionCnt);
    }

    /** How much do we need to pay him based on the questions completed during 
	this phone call?
	// FIXME: need to properly hanlde it in case of resumption.
     */
    public int oughtToPay() {
	int rew = 0;
	for(Action a: actions) {
	    Page p = Page.findPage(a.getPage());
	    rew = Math.max(rew, p.getReward());
	}
	return rew;
    }	
 
    /** Reviews the list of stored actions, and recommends the page
	to reuse the incomplete phone call from. The method tries to
	find the last substantive question that was presented but not answered;
	if none found for some reason (that should not happen), then the last 
	substantive question that was presented AND answered.
	@return Page name, or null if none is found. 
     */
    /*
    public Page shouldResumeFrom() {
	Page lastAnswered = null;
	Page to = null;
	for(Action q: actions) {
	    Page p = Page.findPage(q.getPage());
	    if (p==null || !p.isResumable()) continue;
	    if (q.getQuit() || q.getRefuse() || q.getEndTime()==null) {
		to = p;
	    } else {
		lastAnswered = p;
	    }
	}
	return  (to != null) ? to : lastAnswered;
    }
    */
    public Page shouldResumeFrom(EntityManager em) {
	Page to = null;
	// Avoiding "bad" recursion
	if (getResume()>0 && getResume() < getId()) {
	    User prev = (User)em.find(User.class, getResume());
	    to = prev.shouldResumeFrom(em);
	    
	}

	Page lastAnswered = null;
	for(Action q: actions) {
	    Page p = Page.findPage(q.getPage());
	    if (p==null) continue;
	    
	    if (!p.isResumable()) continue;
	    if (q.getQuit() || q.getRefuse() || q.getEndTime()==null) {
		// was presented, but not answered
		if (p.isResumable() &&  p.compareTo(to)>0) {
		    to = p;
		}
	    } else {
		// was answered
		if (p.isResumable() &&  p.compareTo(lastAnswered)>0) {
		    lastAnswered = p;
		}
	    }
	}
	return  (to != null) ? to : lastAnswered;
    }
 

    public boolean validate(EntityManager em, StringBuffer errmsg) { return true; }


}